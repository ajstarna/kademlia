- probe unit test for timeout and returned

- lookup state machine for values and nodes
    - also need timeouts per request
    - when we get a value back, we are done? (send it back to the channel; see below)
    -  double check the paper on the condition of us ending.
    I think it's if the top k in short_list have already been queried or someting.
        - handle the end of lookups this way. Probably happens if we get nodes back, call top_up, and there are no effects?

    - do we need unit tests with smaller values of k? for now i set k to 20 in all of them, but i guess that means no truncation.
        - maybe a nice big test with a small k, so we need multiple hops.
	Have a find value that needs to get a couple rounds of nodes back,
	some truncation, eventually get the value. Maybe codex can help write this.

- ability for an application to talk to the protocol manager via some API. Basically with a store and get method
    - i think make the DHT a library, and the user would spawn run in a tokio async task then talk to it via a channel.
    - maybe a new KademliaDHT struct that inside its new() it spawns a tokio task to run the protocol manager? And returns
    the channel handle for the user? So the user can interact with the DHT without worrying about the PM running on a task?
    Is this how things are handles? Alternatively the user of the lib would need to run their own task and stuff.
    - have a binary crate along with the library

- bootstrap nodes

- joining the network (there is a described process of requesting yourself or something like that)

- test framework for running multiple nodes.
    - Could this include some unit tests with two protocol managers? Mock sockets right?
        - actually maybe just two DHTs as implemented in the above TODO
    - then some larger integration tests that actually spin up separate nodes and run through some cases.
